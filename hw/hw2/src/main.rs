// Функция double_int32 принимает 32-х битное целое знаковое число и возвращает 32-х битное целое знаковое число, равное удвоенному входному.
fn double_int32(x: u32) -> u32 {
    // x * 2 // В случае переполнения будет паника.
    x.wrapping_mul(2) // игнорирование бита переполнения.
}

// Функция double_int64 принимает 32-х битное целое знаковое число и возвращает 64-х битное целое знаковое число, равное удвоенному входному.
fn double_int64(x: u32) -> u64 {
    x as u64 * 2

    // (x as u64).wrapping_mul(2) // игнорирование бита переполнения.
    // (x as u64).saturating_mul(2) // максимальное значение типа в случае переполнения.
}

// Функция double_float32 принимает 32-х битное число с плавающей точкой и возвращает 32-х битное число с плавающей точкой, равное удвоенному входному.
fn double_float32(x: f32) -> f32 {
    x * 2.0

    // Насколько понял переполнение работает не так как с целыми числами, паники не будет: inf, -inf
    // Можно добавить проверку:
    // let res = x * 2.0;
    // if res.is_infinite() {
    //     panic!("Переполнение");
    // }
}

// Функция double_float64 принимает 32-х битное число с плавающей точкой и возвращает 64-х битное число с плавающей точкой, равное удвоенному входному.
fn double_float64(x: f32) -> f64 {
    x as f64 * 2.0
}

// Функция int_plus_float_to_float принимает 32-х битное целое знаковое число и 32-х битное число с плавающей точкой. Возвращает 64-х битное число с плавающей точкой, равное сумме входных.
fn int_plus_float_to_float(x: i32, y: f32) -> f64 {
    x as f64 + y as f64
}

// Функция int_plus_float_to_int принимает 32-х битное целое знаковое число и 32-х битное число с плавающей точкой. Возвращает 64-х битное целое знаковое число, равное сумме входных.
fn int_plus_float_to_int(x: i32, y: f32) -> i64 {
    x as i64 + y as i64

    // Можно также добавить проверку на переполнение. Например, игнорировать бить переполнения.
    // (x as i64).wrapping_add(y as i64)
}

// Функция tuple_sum принимает кортеж из двух целых чисел. Возвращает целое число, равное сумме чисел во входном кортеже.
fn tuple_sum(two: (u32, u32)) -> u32 {
    two.0 + two.1
}

// Функция array_sum принимает массив из трёх целых чисел. Возвращает целое число, равное сумме чисел во входном массиве.
fn array_sum(tree: [u32; 3]) -> u32 {
    tree[0] + tree[1] + tree[2]
}

fn main() {
    let res1 = double_int32(12);
    println!("double_int32: {}", res1);

    let res2 = double_int64(1204333);
    println!("double_int64: {}", res2);

    let res3 = double_float32(1204333.256);
    println!("double_float32: {}", res3);

    let res4 = double_float64(1204333.256);
    println!("double_float64: {}", res4);

    let res5 = int_plus_float_to_float(12, 1204333.256);
    println!("int_plus_float_to_float: {}", res5);

    let res6 = int_plus_float_to_int(12, 1204333.256);
    println!("int_plus_float_to_int: {}", res6);

    let res7 = tuple_sum((12, 42));
    println!("tuple_sum: {}", res7);

    let res8 = array_sum([1, 2, 3]);
    println!("array_sum: {}", res8);
}
